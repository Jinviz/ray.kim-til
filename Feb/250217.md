# Cookie, Storage, Session, Secure (D+15)
## 쿠키

<aside>
💡

: 서버를 통해 사용자에게 설치되어, 서버의 상태를 저장하고 유지하는 데이터 조각

- 웹 사이트의 방문 정보를 `기억`해 개인화된 서비스 제공을 위해 사용됨
- 브라우저에 텍스트 데이터로 저장
- 웹 서버로부터 모든 정보를 담아 보내기 때문에, 저장소로 이용할 경우 네트워크 오버헤드가 커지기 때문에 이 경우, 스토리지를 활용해야 한다.
</aside>

## 퍼스트파티 쿠키

<aside>
💡

:사용자가 `직접 방문한 곳`에서 설정한 쿠키

![image](https://github.com/user-attachments/assets/24407738-4d96-437f-8d2c-283bc52d5f20)


- 쿠키의 출처 = 방문 중인 도메인 주소

e.g. 로그인상태, 장바구나정보 등의 웹사이트 자체 기능 향상을 위해 사용됨

</aside>

## 서드파티 쿠키

<aside>
💡

: 방문한 웹 사이트와 `다른 곳`에서 설정한 쿠키

 

![image](https://github.com/user-attachments/assets/4a5a3a19-6b3e-451e-a30f-f33c96d5eda1)


- 쿠키의 출처 ≠ 방문 중인 도메인 주소

e.g.  Google Ads와 같은 광고 서비스(사용자 관심사 맞춤형 광고)

</aside>

## 쿠키 보안 속성

<aside>
💡

1. Secure
- MITM(중간자공격)을 방지하기 위해, `HTTPS` 연결에서만 쿠키를 전송되게 함
    
    ![image](https://github.com/user-attachments/assets/e5a36e1f-57ca-4cfc-813b-90495b78f4a5)

    
1. HttpOnly
- `자바스크립트`에서 해당 쿠키에 접근할 수 없음
- XXS(크로스 사이트 스크립팅) 공격으로부터 쿠키 탈취 방지
    
    ![image](https://github.com/user-attachments/assets/b68d9473-4b80-4f64-8f9a-bf895bffaee0)

    
1. SameSite  
- `퍼스트파티`에서만 쿠키가 전송되도록 제한
- CSRF(크로스 사이트 요청 위조) 공격 방지하는 역할
    
    ![image](https://github.com/user-attachments/assets/6154d2f1-5934-407f-8eef-204b1c3e45dd)

    
    SameSite 옵션
    
    | Strict | 퍼스트파티 쿠키 전송만 허용 |
    | --- | --- |
    | Lax | Get요청에서만 서드파티쿠키 전송 허용 |
    | None | 모든 서드파티쿠키 허용 (Secure 설정 시에만) |
</aside>

## 세션

<aside>
💡

: 데이터 송수신을 마칠 떄까지의 기간의 상태정보

- 통신의 열고 닫히는 것이 한 세트
- 로그인과 로그아웃 전까지, 요청과 응답 전까지 등등
- 서버에서의 별도의 저장소가 필요
- 쿠키의 장단점을 뒤집으면 세션이 된다.
    - 쿠키는 클라이언트 측에서 관리할 때의 장단점
        - 비교적 비용 저렴하고 쉽게 사용
        - 안전하지 않은 브라우저에 저장, 브라우저 간 공유 불가(지역성 문제)
    - 세션은 서버 측에서 관리할 떄의 장단점
        - 안정한 저장(보안성), 네트워크 오버헤드 감소(쿠키 데이터 포함x)
        - 비용 문제(메모리 기반)
- 웹 서버 측에 저장함으로 네트워크 요청 크기에 영향이 없다. 하지만, 매 요청마다 세션을 조회함으로 Redis와 같은 고속 데이터베이스 사용을 고려해야 한다.

### 세션 저장 방식 3가지

1. InMemory: 코드(변수)로 저장하는 방식
2. File Storage: 파일 생성 후 텍스트로 저장
3. Database: DB 칼럼에 세션 저장
</aside>

## 세션 ID와 쿠키의 관계

<aside>
💡

세션 ID를 브라우저의 `쿠키`에 저장하고, 

클라이언트 요청에 `세션 ID` 정보를 포함하여 서버로 전송하게 되면

서버 저장소에서 해당 `세션`을 `조회`한다.

</aside>

## 로컬 스토리지

<aside>
💡

: 영구적으로 저장되는 브라우저 저장소 

- 장기적으로 유지되어야 하는 데이터 저장 (사용자 설정,테마,즐겨찾기 등)
</aside>

## 세션 스토리지

<aside>
💡

: 창을 닫으면 삭제되는 브라우저 저장소

- 세션 동안에만 필요한 일시적인 데이터 저장 (페이지 간 데이터 전달, 일시적 상태 정보)
</aside>

##  HTTP가 본질적으로 Stateless하다는 의미와, 웹 애플리케이션에서 상태 유지를 위해 어떤 기법(예: 세션, 쿠키)을 사용하는지 설명해 주세요.

<aside>
💡

## ❕쿠키의 방식에 따라 HTTP 통신이 Stateful할 수도 Stateless할 수도 있다.

<aside>

**HTTP의 상태 특성**

| Stateful | 서버가 클라이언트의 이전 요청 데이터를 기억하고 있음 |
| --- | --- |
| Stateless | 서버가 각 요청을 독립적으로 처리하고, 이전 요청의 정보를 유지하지 않음 |
</aside>

1. **Stateful**

http는 기본적으로 Stateless(각 요청이 독립적)이지만, 쿠키를 사용함으로써 서버가 이전 요청의 상태를 기억할 수 있다.(Stateful)

- session_id 저장 (로그인 상태)
- 장바구니 정보
- 다크모드, 언어 설정
1. **Stateless**

쿠키 설계 방식에 따라 Stateless한 특성을 지닐 수도 있다. 

`JWT` 는 자체에 필요한 정보가 모두 포함되어 있기 때문에 서버에서 별도로 상태를 저장하지 않는다.

별도의 세션을 유지할 필요 없이 토큰 검증만 수행하면 되기 때문이다.

**하지만**, 예외적으로 `RefreshToken`을 DB에서 저장해서 관리하는 경우, Stateful한 방식이 된다. 

</aside>

##  매 요청 시 쿠키가 전송됨에 따른 네트워크 오버헤드 문제와, 이를 완화할 수 있는 방법에는 어떤 것이 있는지 논의해 주세요.

<aside>
💡

### 이에 대한 나의 고민

`쿠키`로 로그인 상태를 관리하지 않고, `JWT 토큰`을 `로컬스토리지`에 저장하고 필요한 요청에만 `Athorization 헤더`에 포함시킨다면 무분별하게 매 요청마다 `Cookie헤더`에 쿠키가 포함되진 않으니 네트워크 오버헤드 문제 측면에서는 완화할 수 있는 방법이 되지 않을까? 

</aside>

##  쿠키의 만료 시간을 설정하는 Expires와 Max-Age 옵션의 차이점은 무엇인지 설명해 주세요.

<aside>
💡

: 옵션을 설정하지 않은 쿠키는 `Session Cookie(세션 쿠키)`라고 하고 만료 시간이 설정된 쿠키는 `Persistent Cookie(영속성 쿠키)`라고 한다.

- 세션 쿠키는 브라우저를 닫으면 사라진다.

### Expires

절대적인 만료 시간을 지정
예시: `Set-Cookie: name=value; Expires=Wed, 21 Feb 2024 07:28:00 GMT`

### Max-Age

상대적인 만료 시간을 초 단위로 지정
예시: `Set-Cookie: name=value; Max-Age=3600` (1시간 후 만료)

</aside>

##  CSRF 공격이란 무엇이며, SameSite 속성을 통해 이를 어떻게 예방할 수 있는지 설명해 주세요.
Cross-site Request Forgery
<aside>
💡

**`특정 사이트가 사용자를 신뢰`** 하기 때문에 발생하는 문제 ( 사용자의 요청 이용)

Cross-Site Request Forgery

- 사용자가 자신의 의지와는 무관하게 침입자가 의도한 행위를 서버에 요청하게 만드는 공격
    
    ![image](https://github.com/user-attachments/assets/2919cf29-e2b2-48f7-96da-091f1c45358a)

    
- 사용자가 인증이 된 상태를 활용하여, 악의적으로 스크립트(피싱 사이트)를 노출시켜 사용자가  `의도치 않게` 중요한 동작(요청)을 수행하도록 한다.

> 💡 CSRF의 2가지 조건
> 
> 
> 1. 사용자가 사이트에 로그인 상태여야 한다.
> 
> 2. 사용자는 조작된 페이지에 방문(접속)해야 한다.
> 

### Samsite

**쿠키가 다른 출처에서 자동으로 전송되지 않도록 설정하면** CSRF 공격을 방어할 수 있다.

SameSite 옵션

| Strict | 퍼스트파티 쿠키 전송만 허용 |
| --- | --- |
| Lax | Get요청에서만 서드파티쿠키 전송 허용 |
| None | 모든 서드파티쿠키 허용 (Secure 설정 시에만) |
</aside>

|  | XSS | CSRF |
| --- | --- | --- |
| 방법 | 악성 스크립트가 클라이언트에서 실행 | 권한을 도용당한 클라이언트가 가짜 요청을 서버에 전송 |
| 원인 | 사용자가 특정 사이트를 신뢰 | 특정 사이트가 사용자를 신뢰 |
| 공격대상 | 클라이언트 | 서버 |
| 목적 | 쿠키, 세션 갈취, 웹사이트 변조 | 권한 도용 |

##  XSS 공격의 동작 원리와, HttpOnly 속성이 쿠키를 보호하는 방식에 대해 설명해 주세요.
xss 크로스 사이트 스크립팅

<aside>
💡

**`사용자가 특정 사이트를 신뢰`**하기 때문에 발생하는 문제라면 ( 사용자에 실행되는 응답 이용)

![image](https://github.com/user-attachments/assets/d85c3a95-add8-4678-99da-047cb1655d39)


### XSS 공격의 동작 원리

<aside>
💡

스크립트 코드를 삽입하여 사용자 단에서 실행되게 하는 공격 원리

</aside>

1. 공격자가 악성 JavaScript 코드를 삽입
    - 댓글이나 게시글에 `<script>` 태그 삽입
    - URL 파라미터를 통한 스크립트 주입
    - 이벤트 핸들러 속성 악용 (예: `<img onerror="...">`)
2. 사용자가 해당 페이지를 방문하면 삽입된 악성 코드가 실행됨
3. 악성 코드는 사용자의 브라우저에서 다음과 같은 작업을 수행
    - document.cookie를 통해 쿠키 탈취
    - localStorage/sessionStorage 접근
    - 사용자 입력 가로채기
    - AJAX 요청을 통한 데이터 유출
    - DOM 조작을 통한 피싱

### HttpOnly 보안 속성

HttpOnly 플래그가 설정된 쿠키는 JavaScript를 통해 접근이 불가능

- document.cookie로 읽기 불가
- document.cookie로 수정 불가

but, HTTP 요청 시에는 자동으로 포함됨

</aside>
