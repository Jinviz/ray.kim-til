# 공유 자원, 임계 영역, 동기화, 락, 조건 변수, 세마포어 (D+8)

## 공유 자원
![image](https://github.com/user-attachments/assets/e14ac77e-3ae5-4ae0-abd7-a1d204bf25c1)

- 여러 사용자나 프로세스가 `동시에 접근`하거나 `사용`하는 시스템 내의 `자원`을 의미
- 리소스 낭비를 방지하고 효율성을 극대하기 위해 사용
- e.g. 메모리, 파일시스템, 네트워크 프린터, 데이터베이스

## 임계 영역
![image](https://github.com/user-attachments/assets/e7e8a87a-7be9-4962-8be6-c15527ec8d0e)

- 공유 자원을 사용하려는 프로그램 내부의 코드 중에서도 `충돌이 발생할 가능성`이 있는 부분
- e.g. 여러 스레드가 동일한 변수나 메모리 영역을 수정하거나 파일에 쓰기 작업을 하는 코드 부분

### 임계 영역 문제 상황
- 쓰레드1과 2가 동시에 아래의 코드를 실행한다고 했을 때, 하나의 코드 동작이 손실될 가능성이 있음.
```java
int temp = balance;  // 1. 잔액 읽기
temp += 100;         // 2. 잔액 수정 (100원을 입금)
balance = temp;      // 3. 수정된 잔액 저장
```

- 공유 자원 전체를 보호해야 하는 것이 아니라, 그 자원을 다루는 코드 중에서 `위험한 부분(임계 영역)`만 보호하면 된다.
- 데이터의 `무결성 유지`와 `경쟁 상태(경합 조건)` 방지 해야 한다.

> #### 경쟁 상태 (Race Condition)
> 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 `경쟁`하는 상황
> 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상

## 동기화 (Synchronization)
- 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 방지하고 순서를 올바르게 조정하는 작업
- 멀티 스레드 환경에서 발생할 수 있는 `경쟁 상태(Race Condition)`와 `교착 상태(Dead Lock)`을 방지

### 동기화 특징
1. 순서 보장: 여러 작업의 접근 순서 조정하여 충돌 방지
2. 공유 자원 보호: 공유 자원 데이터 무결성 유지
3. 경합 문제 해결: 동시적 자원 접근에 의한 데이터 손실 방지 

### 동기화 상황
1. 데이터 무결성 손실
   - e.g. 은행 계좌 잔고를 갱신하는 두 트랜잭션이 동기화 없이 실행되면, 잔고가 잘못 계산되어 데이터 불일치가 발생
3. 데이터 경쟁 상태(Race Condition)
   - e.g. 동일한 파일을 업로드하거나 수정할 경우, 데이터가 덮어쓰이거나 손상될 위험이 있음
5. 데드락(Deadlock)
   - e.g. 한 스레드가 A 자원을 점유한 상태에서 B를 기다리고, 다른 스레드가 B를 점유하며 A를 기다릴 경우 시스템이 멈출 수 있음# 공유 자원, 임계 영역, 동기화, 락 (D+8)

> #### 동기화 실전 활용
> FE: Web Worker를 활용한 병렬 처리 제어
> BE: 데이터베이스 연결풀 관리

### 동작 방식
![image](https://github.com/user-attachments/assets/e4ae3341-c96e-401d-bf4f-44d7f4ce8fee)
#### 임계 영역 문제를 해결할 수 있는 3가지 메커니즘
: 임계 영역 문제를 해결하려면 아래의 3가지 조건을 충족해야 함
1. Mutual Exclusion (상호 배제)
   - 하나의 프로세스가 임계 영역에서 실행 중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없음.
3. Progress (진행)
   - 공유 자원에 접근 중인 프로세스가 없고, 대기 중인 프로세스가 있다면 반드시 임계 영역에 들어가 실행되어야 함.
4. Bounded Waiting (유한한 대기)
   - 특정 프로세스가 공유 자원에 접근하려고 요청하면, 무한히 기다리지 않고 언젠가는 실행 기회를 보장.
  
#### 메커니즘을 이용한 3가지 방법
1. Lock/Mutex <Mutual-Exclusion(상호배제)>
   - 배타적 접근 설정
   - e.g. 데이터베이스 갱신, 파일I/O
3. Condition Variable <Progress(진행)>
   - 특정 조건이 충족될 때까지 대기 후 신호로 재개
   - e.g. 생성자-소비자 패턴, 이벤트 대기
4. Semaphore <Mutual-Exclusion(상호배제) + Bounded Waiting(유한한 대기)>
   - 허용량 설정으로 동시 접근을 제한
   - 다중 자원 접근 제어
   - e.g. 네트워크 접속 제한, 스레드 풀 관리

## 임계 영역 해결 방식 (락, 상태변수, 세마포어)
- 하나의 스레드나 프로세스가 자원을 점유할 경우 다른 스레드/프로세스가 해당 자원에 접근하지 못하도록 제어하는 기법
- 상호 배제(Mutual Exclusion)을 하기 위한 기법
- 원자성을 통해 작업 단위가 안전하게 수행되도록 보장함

### 락의 종류
1. 스핀락 (Spin Lock)
   - 반복적으로 락 상태를 확인하여 다음 접근을 하도록 함 (busy-waiting)
     1. Thread 점유 및 작업 수행
     ![image](https://github.com/user-attachments/assets/5d5592b0-f3c7-42c2-9c61-71a5757db80b)
     2. 스핀락의 busy-waiting 상태
     ![image](https://github.com/user-attachments/assets/6818d8e0-5a98-47e7-b156-e2b42ccb0f14)
    - 컨텍스트 스위칭이 없어 오버헤드는 적지만, busy-waiting으로 인한 CPU 자원의 비효율 사용 가능성 존재
    - `단일 CPU 환경`에서는 애초에 스레드의 점유와 대기가 공전이 불가능해서 비효율적임
2. 낙관적 락 (Optimistic Lock)
   - `락을 수행하지 않음`
   - 데이터 충돌이 드물다는 가정하에 락 없이 작업을 수행하고, 충돌이 발생하면 롤백을 통해 해결하는 방식
     ![image](https://github.com/user-attachments/assets/b45e72b5-b6e8-4940-bf10-0f4983fa7374)

     > #### Thread 2가 나중에 요청했는데 Thread 1이 롤백 하는 이유가 무엇인지?
     > **충돌 탐지 시점**을 생각해보면  스레드 2는 추가 요청을 하고, 이미 스레드 1과 겹치는 데이터를 수정하려 한 상황입니다.
     > 그렇기에 이미 바꿔야하는 데이터라고 판단하여 스레드 1을 롤백하는 것입니다.
     > 물론 스레드 2를 롤백하도록 할 수 도 있습니다.

3. 뮤텍스 (Mutex)
   - Mutex의 어원은 Mutual Exclusion의 약어
   - 락의 소유권과 해제 권한을 특정 스레드에 부여하는 것이 특징
     ![image](https://github.com/user-attachments/assets/6deec158-062e-4c45-8f4b-b7c66ba89a5d)
     ![image](https://github.com/user-attachments/assets/d9344927-e6ab-4726-9667-c277bbabccfc)

> #### 뮤텍스와 조건 변수 (Condition Variable)
> 조건 변수는 일반적으로 뮤텍스 락(Mutex Lock)과 함께 동작하며, 이를 통해 공유 자원에 안전하게 접근할 수 있도록 설계
> 스레드가 불필요하게 CPU를 점유하지 않고 조건이 충족될 때만 깨어나도록 설계
> 뮤텍스 대기 큐:
> 뮤텍스 락이 현재 소유 중인 스레드에 의해 해제되면, 대기 중인 스레드(Task) 중 하나가 큐에서 dequeue되어 락을 획득할 기회를 가집니다.
> 이 큐는 뮤텍스를 점유하지 못한 스레드들의 대기 목록을 관리하며, 락 점유 상태를 조율하는 역할을 합니다.
> 조건 변수 대기 큐:
> 특정 조건이 true가 될 때 대기 중인 task가 dequeue됩니다.
> 조건 변수는 논리적 조건이 충족되지 않은 동안 스레드를 대기 상태로 유지하고, 조건이 충족될 때만 스레드를 깨웁니다.


   
